package check

import (
	"fmt"
	"math"
	"math/big"
	"path"
	"reflect"
	"runtime"
	"runtime/debug"
	"strings"
	"testing"
	"time"

	"github.com/thatguystone/cog/stringc"
)

// Can't really get 100% coverage on this file: doing so causes the tests to
// fail.
//gocovr:skip-file

// An Asserter provides test assertions. Each assertion returns if the
// assertion succeeded.
type Asserter interface {
	// True checks that the given bool is true.
	True(cond bool, msg ...interface{}) bool

	// False checks that the given bool is false.
	False(cond bool, msg ...interface{}) bool

	// Equal compares two things, ensuring that they are equal to each other.
	// `e` is the expected value; `g` is the value you got somewhere else.
	//
	// Equal takes special care of floating point numbers, ensuring that any
	// precision loss doesn't affect their equality.
	Equal(g, e interface{}, msg ...interface{}) bool

	// NotEqual is the opposite of Equal.
	NotEqual(g, e interface{}, msg ...interface{}) bool

	// Len checks that the length of the given v is l.
	Len(v interface{}, l int, msg ...interface{}) bool

	// NotLen is the opposite of Len.
	NotLen(v interface{}, l int, msg ...interface{}) bool

	// Contains checks that iter contains v.
	//
	// The following checks are done:
	//    0) If a map, checks if the map contains key v.
	//    1) If iter is a slice/array and v is a slice/array, checks to see if
	//       v is a subset of iter.
	//    2) If iter is a slice/array and v is not, checks if any element in
	//       iter equals v.
	//    3) If iter is a string, falls back to strings.Contains.
	Contains(iter, v interface{}, msg ...interface{}) bool

	// NotContains is the opposite of Contains.
	NotContains(iter, v interface{}, msg ...interface{}) bool

	// Is ensures that g is the same type as e.
	Is(g, e interface{}, msg ...interface{}) bool

	// NotIs is the exact opposite of Is.
	NotIs(g, e interface{}, msg ...interface{}) bool

	// Nil ensures that g is nil. This is a strict equality check.
	Nil(g interface{}, msg ...interface{}) bool

	// NotNil is the opposite of Nil.
	NotNil(g interface{}, msg ...interface{}) bool

	// Panics ensures that the given function panics
	Panics(fn func(), msg ...interface{}) bool

	// NotPanics ensures that the given function does not panic
	NotPanics(fn func(), msg ...interface{}) bool

	// Until polls for the given function for the given amount of time. If in
	// that time the function did not return true, the test fails immediately.
	Until(wait time.Duration, fn func() bool, msg ...interface{})

	// UntilNil polls the given function for iters or until it doesn't return an
	// error. This is mainly a helper used to exhaust error pathways when using
	// an Errorer.
	UntilNil(iters int, fn func() error, msg ...interface{})
}

type assert struct {
	testing.TB
	onFail func()
}

func newNoopAssert(tb testing.TB) assert {
	return assert{
		TB:     tb,
		onFail: func() {},
	}
}

func newMustAssert(tb testing.TB) assert {
	return assert{
		TB: tb,
		onFail: func() {
			tb.FailNow()
		},
	}
}

func format(msg ...interface{}) string {
	if len(msg) == 0 {
		return ""
	} else if len(msg) == 1 {
		return msg[0].(string)
	} else {
		return fmt.Sprintf(msg[0].(string), msg[1:]...)
	}
}

func callerInfo() string {
	var in string

	for i := 0; ; i++ {
		pc, file, line, ok := runtime.Caller(i)
		if !ok {
			return "???:1"
		}

		if strings.HasSuffix(file, "/cog/check/assert.go") {
			continue
		}

		file = path.Base(file)

		fn := runtime.FuncForPC(pc)
		if strings.Contains(fn.Name(), ".Test") {
			if in == "" {
				return fmt.Sprintf("%s:%d", file, line)
			}

			return fmt.Sprintf("%s (from %s:%d)", in, file, line)
		}

		if in == "" && file != "<autogenerated>" {
			in = fmt.Sprintf("%s:%d", file, line)
		}
	}
}

func (a assert) getInt(e interface{}) (*big.Int, bool) {
	i := big.NewInt(0)

	v := reflect.ValueOf(e)
	switch v.Kind() {
	case reflect.Int,
		reflect.Int8,
		reflect.Int16,
		reflect.Int32,
		reflect.Int64:

		i.SetInt64(v.Int())

	case reflect.Uint,
		reflect.Uint8,
		reflect.Uint16,
		reflect.Uint32,
		reflect.Uint64:

		i.SetUint64(v.Uint())

	default:
		return nil, false
	}

	return i, true
}

func (a assert) intEqual(g, e interface{}) bool {
	ex, ok1 := a.getInt(e)
	gx, ok2 := a.getInt(g)
	if !ok1 || !ok2 {
		return false
	}

	return ex.Cmp(gx) == 0
}

func (a assert) floatingEqual(g, e interface{}) bool {
	fe, ok := e.(float64)
	if !ok {
		return false
	}

	fg, ok := g.(float64)
	if !ok {
		return false
	}

	min := math.Min(fe, fg)
	max := math.Max(fe, fg)

	return math.Nextafter(min, max) == max
}

func (a assert) equal(g, e interface{}) bool {
	if reflect.DeepEqual(g, e) {
		return true
	}

	if a.intEqual(g, e) {
		return true
	}

	if a.floatingEqual(g, e) {
		return true
	}

	return false
}

func (a assert) contains(iter, v interface{}) (found, ok bool) {
	ok = true

	iterV := reflect.ValueOf(iter)
	vv := reflect.ValueOf(v)
	defer func() {
		if e := recover(); e != nil {
			ok = false
		}
	}()

	if iterV.Kind() == reflect.Map {
		keys := iterV.MapKeys()
		for _, k := range keys {
			if a.equal(k.Interface(), v) {
				found = true
				return
			}
		}

		return
	}

	if iterV.Kind() == reflect.Slice || iterV.Kind() == reflect.Array {
		if vv.Kind() == reflect.Slice || vv.Kind() == reflect.Array {
			at := 0

			for i := 0; i < iterV.Len(); i++ {
				if at == vv.Len() {
					break
				}

				if a.equal(iterV.Index(i).Interface(), vv.Index(at).Interface()) {
					at++
				} else {
					at = 0
				}
			}

			found = at == vv.Len()
		} else {
			for i := 0; i < iterV.Len(); i++ {
				if a.equal(iterV.Index(i).Interface(), v) {
					found = true
					break
				}
			}
		}

		return
	}

	if vv.Kind() == reflect.String {
		found = strings.Contains(iterV.String(), vv.String())
		return
	}

	ok = false
	return
}

func (a assert) errorf(format string, args ...interface{}) {
	a.Helper()
	a.Errorf(format, args...)
	a.onFail()
}

func (a assert) True(cond bool, msg ...interface{}) bool {
	if !cond {
		a.Helper()
		a.errorf("%s\n"+
			"Bool check failed: expected true",
			format(msg...))
	}

	return cond
}

func (a assert) False(cond bool, msg ...interface{}) bool {
	if cond {
		a.Helper()
		a.errorf("%s\n"+
			"Bool check failed: expected false",
			format(msg...))
	}

	return !cond
}

func (a assert) Equal(g, e interface{}, msg ...interface{}) bool {
	if !a.equal(g, e) {
		diff := diff(g, e)

		if diff != "" {
			diff = "\n\nDiff:\n" + stringc.Indent(diff, spewConfig.Indent)
		}

		g, e := fmtVals(g, e)

		a.Helper()
		a.errorf("%s\n"+
			"Expected: `%+v`\n"+
			"       == `%+v`%s",
			format(msg...),
			g, e, diff)
		return false
	}

	return true
}

func (a assert) NotEqual(g, e interface{}, msg ...interface{}) bool {
	if a.equal(g, e) {
		a.Helper()
		a.errorf("%s\n"+
			"Expected: `%+v`\n"+
			"       != `%+v`",
			format(msg...),
			g, e)
		return false
	}

	return true
}

func getLen(v interface{}) (n int, ok bool) {
	defer func() { recover() }()

	n = reflect.ValueOf(v).Len()
	ok = true
	return
}

func (a assert) Len(v interface{}, l int, msg ...interface{}) (eq bool) {
	n, ok := getLen(v)
	if !ok {
		a.Helper()
		a.errorf("%s\n"+
			"%+v is not iterable, cannot check length",
			format(msg...),
			v)
		return false
	}

	if !a.Equal(n, l, msg...) {
		a.Helper()
		return false
	}

	return true
}

func (a assert) NotLen(v interface{}, l int, msg ...interface{}) (eq bool) {
	n, ok := getLen(v)
	if !ok {
		a.Helper()
		a.errorf("%s\n"+
			"%+v is not iterable, cannot check length",
			format(msg...),
			v)
		return false
	}

	if !a.NotEqual(n, l, msg...) {
		a.Helper()
		return false
	}

	return true
}

func (a assert) Contains(iter, v interface{}, msg ...interface{}) bool {
	found, ok := a.contains(iter, v)

	if !ok {
		a.Helper()
		a.errorf("%s\n"+
			"%+v is not iterable; contain check failed",
			format(msg...),
			v)
		return false
	}

	if !found {
		a.Helper()
		a.errorf("%s\n"+
			"%#v does not contain %#v",
			format(msg...),
			iter,
			v)
		return false
	}

	return true
}

func (a assert) NotContains(iter, v interface{}, msg ...interface{}) bool {
	found, ok := a.contains(iter, v)

	if !ok {
		a.Helper()
		a.Errorf("%s\n"+
			"%+v is not iterable; contain check failed",
			format(msg...),
			v)
		return false
	}

	if found {
		a.Helper()
		a.Errorf("%s\n"+
			"%#v contains %#v",
			format(msg...),
			iter,
			v)
		return false
	}

	return true
}

func (a assert) Is(g, e interface{}, msg ...interface{}) bool {
	te := reflect.TypeOf(e)
	tg := reflect.TypeOf(g)

	if !a.equal(te, tg) {
		a.Helper()
		a.Errorf("%s\n"+
			"Expected type: %s.%s\n"+
			"            == %s.%s",
			format(msg...),
			te.PkgPath(), te.Name(),
			tg.PkgPath(), tg.Name())
		return false
	}

	return true
}

func (a assert) NotIs(g, e interface{}, msg ...interface{}) bool {
	te := reflect.TypeOf(e)
	tg := reflect.TypeOf(g)

	if a.equal(te, tg) {
		a.Helper()
		a.errorf("%s\n"+
			"Expected type: %s.%s\n"+
			"            != %s.%s",
			format(msg...),
			te.PkgPath(), te.Name(),
			tg.PkgPath(), tg.Name())
		return false
	}

	return true
}

func (a assert) Nil(g interface{}, msg ...interface{}) bool {
	if g != nil {
		a.Helper()
		a.errorf("%s\n"+
			"Expected nil, got: `%+v`",
			format(msg...),
			g)
		return false
	}

	return true
}

func (a assert) NotNil(g interface{}, msg ...interface{}) bool {
	if g == nil {
		a.Helper()
		a.errorf("%s\n"+
			"Expected something, got nil",
			format(msg...))
		return false
	}

	return true
}

func (a assert) Panics(fn func(), msg ...interface{}) (ok bool) {
	defer func() { recover() }() // Can't just defer recover(), apparently
	ok = true
	fn()

	ok = false
	a.Helper()
	a.errorf("%s\n"+
		"Expected fn to panic; it did not.",
		format(msg...))

	return
}

func (a assert) NotPanics(fn func(), msg ...interface{}) (ok bool) {
	var r interface{}
	var stack string

	// Need to do the check in a different function, otherwise a.Helper()
	// doesn't work (it reports that the callsite is in some .s file)
	func() {
		defer func() {
			if !ok {
				r = recover()
				stack = string(debug.Stack())
			}
		}()

		fn()
		ok = true
	}()

	if !ok {
		a.Helper()
		a.errorf("%s\n"+
			"Expected fn not to panic; got: %+v\n%s",
			format(msg...),
			r,
			stringc.Indent(stack, "\t"))
	}

	return ok
}

func (a assert) Until(timeout time.Duration, fn func() bool, msg ...interface{}) {
	deadline := time.Now().Add(timeout)
	sleep := timeout / 1000
	for time.Now().Before(deadline) {
		if fn() {
			return
		}

		time.Sleep(sleep)
	}

	a.errorf("%s\n"+
		"Waiting for condition failed",
		format(msg...))
	a.FailNow()
}

func (a assert) UntilNil(iters int, fn func() error, msg ...interface{}) {
	var err error

	for i := 0; i < iters; i++ {
		err = fn()
		if err == nil {
			return
		}
	}

	a.Helper()
	a.errorf("%s\n"+
		"Func didn't succeed after %d tries, last err: %v",
		format(msg...),
		iters, err)
}
