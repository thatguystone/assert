// Code generated by `go generate check.cmd.go`. DO NOT EDIT.

package check

//gocovr:skip-file

import "fmt"

// Check that the given bool is true.
func True(t Error, cond bool) bool {
	if msg, ok := checkTrue(cond); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that the given bool is true.
func Truef(t Error, cond bool, format string, args ...any) bool {
	if msg, ok := checkTrue(cond); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that the given bool is true.
func MustTrue(t Fatal, cond bool) {
	if msg, ok := checkTrue(cond); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that the given bool is true.
func MustTruef(t Fatal, cond bool, format string, args ...any) {
	if msg, ok := checkTrue(cond); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that the given bool is false.
func False(t Error, cond bool) bool {
	if msg, ok := checkFalse(cond); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that the given bool is false.
func Falsef(t Error, cond bool, format string, args ...any) bool {
	if msg, ok := checkFalse(cond); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that the given bool is false.
func MustFalse(t Fatal, cond bool) {
	if msg, ok := checkFalse(cond); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that the given bool is false.
func MustFalsef(t Fatal, cond bool, format string, args ...any) {
	if msg, ok := checkFalse(cond); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that two things are equal; e is the expected value, g is what was got.
func Equal(t Error, g, e any) bool {
	if msg, ok := checkEqual(g, e); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that two things are equal; e is the expected value, g is what was got.
func Equalf(t Error, g, e any, format string, args ...any) bool {
	if msg, ok := checkEqual(g, e); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that two things are equal; e is the expected value, g is what was got.
func MustEqual(t Fatal, g, e any) {
	if msg, ok := checkEqual(g, e); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that two things are equal; e is the expected value, g is what was got.
func MustEqualf(t Fatal, g, e any, format string, args ...any) {
	if msg, ok := checkEqual(g, e); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that two things are not equal; e is the expected value, g is what was got.
func NotEqual(t Error, g, e any) bool {
	if msg, ok := checkNotEqual(g, e); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that two things are not equal; e is the expected value, g is what was got.
func NotEqualf(t Error, g, e any, format string, args ...any) bool {
	if msg, ok := checkNotEqual(g, e); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that two things are not equal; e is the expected value, g is what was got.
func MustNotEqual(t Fatal, g, e any) {
	if msg, ok := checkNotEqual(g, e); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that two things are not equal; e is the expected value, g is what was got.
func MustNotEqualf(t Fatal, g, e any, format string, args ...any) {
	if msg, ok := checkNotEqual(g, e); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that v is nil. This is a strict equality check.
func Nil(t Error, v any) bool {
	if msg, ok := checkNil(v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that v is nil. This is a strict equality check.
func Nilf(t Error, v any, format string, args ...any) bool {
	if msg, ok := checkNil(v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that v is nil. This is a strict equality check.
func MustNil(t Fatal, v any) {
	if msg, ok := checkNil(v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that v is nil. This is a strict equality check.
func MustNilf(t Fatal, v any, format string, args ...any) {
	if msg, ok := checkNil(v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that v is not nil. This is a strict equality check.
func NotNil(t Error, v any) bool {
	if msg, ok := checkNotNil(v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that v is not nil. This is a strict equality check.
func NotNilf(t Error, v any, format string, args ...any) bool {
	if msg, ok := checkNotNil(v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that v is not nil. This is a strict equality check.
func MustNotNil(t Fatal, v any) {
	if msg, ok := checkNotNil(v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that v is not nil. This is a strict equality check.
func MustNotNilf(t Fatal, v any, format string, args ...any) {
	if msg, ok := checkNotNil(v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that v is the zero value for its type.
func Zero(t Error, v any) bool {
	if msg, ok := checkZero(v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that v is the zero value for its type.
func Zerof(t Error, v any, format string, args ...any) bool {
	if msg, ok := checkZero(v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that v is the zero value for its type.
func MustZero(t Fatal, v any) {
	if msg, ok := checkZero(v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that v is the zero value for its type.
func MustZerof(t Fatal, v any, format string, args ...any) {
	if msg, ok := checkZero(v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that v is not the zero value for its type.
func NotZero(t Error, v any) bool {
	if msg, ok := checkNotZero(v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that v is not the zero value for its type.
func NotZerof(t Error, v any, format string, args ...any) bool {
	if msg, ok := checkNotZero(v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that v is not the zero value for its type.
func MustNotZero(t Fatal, v any) {
	if msg, ok := checkNotZero(v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that v is not the zero value for its type.
func MustNotZerof(t Fatal, v any, format string, args ...any) {
	if msg, ok := checkNotZero(v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that [errors.Is] returns true.
func ErrIs(t Error, err, target error) bool {
	if msg, ok := checkErrIs(err, target); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that [errors.Is] returns true.
func ErrIsf(t Error, err, target error, format string, args ...any) bool {
	if msg, ok := checkErrIs(err, target); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that [errors.Is] returns true.
func MustErrIs(t Fatal, err, target error) {
	if msg, ok := checkErrIs(err, target); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that [errors.Is] returns true.
func MustErrIsf(t Fatal, err, target error, format string, args ...any) {
	if msg, ok := checkErrIs(err, target); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that [errors.As] returns true.
func ErrAs(t Error, err error, target any) bool {
	if msg, ok := checkErrAs(err, target); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that [errors.As] returns true.
func ErrAsf(t Error, err error, target any, format string, args ...any) bool {
	if msg, ok := checkErrAs(err, target); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that [errors.As] returns true.
func MustErrAs(t Fatal, err error, target any) {
	if msg, ok := checkErrAs(err, target); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that [errors.As] returns true.
func MustErrAsf(t Fatal, err error, target any, format string, args ...any) {
	if msg, ok := checkErrAs(err, target); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that map m contains key k.
func HasKey(t Error, m, k any) bool {
	if msg, ok := checkHasKey(m, k); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that map m contains key k.
func HasKeyf(t Error, m, k any, format string, args ...any) bool {
	if msg, ok := checkHasKey(m, k); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that map m contains key k.
func MustHaveKey(t Fatal, m, k any) {
	if msg, ok := checkHasKey(m, k); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that map m contains key k.
func MustHaveKeyf(t Fatal, m, k any, format string, args ...any) {
	if msg, ok := checkHasKey(m, k); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that map m does not contain key k.
func NotHasKey(t Error, m, k any) bool {
	if msg, ok := checkNotHasKey(m, k); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that map m does not contain key k.
func NotHasKeyf(t Error, m, k any, format string, args ...any) bool {
	if msg, ok := checkNotHasKey(m, k); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that map m does not contain key k.
func MustNotHaveKey(t Fatal, m, k any) {
	if msg, ok := checkNotHasKey(m, k); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that map m does not contain key k.
func MustNotHaveKeyf(t Fatal, m, k any, format string, args ...any) {
	if msg, ok := checkNotHasKey(m, k); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that iter contains value v. Iter must be one of: map, slice, array, or string.
func Contains(t Error, iter, v any) bool {
	if msg, ok := checkContains(iter, v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that iter contains value v. Iter must be one of: map, slice, array, or string.
func Containsf(t Error, iter, v any, format string, args ...any) bool {
	if msg, ok := checkContains(iter, v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that iter contains value v. Iter must be one of: map, slice, array, or string.
func MustContain(t Fatal, iter, v any) {
	if msg, ok := checkContains(iter, v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that iter contains value v. Iter must be one of: map, slice, array, or string.
func MustContainf(t Fatal, iter, v any, format string, args ...any) {
	if msg, ok := checkContains(iter, v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that iter does not contain value v. Iter must be one of: map, slice, array, or string
func NotContains(t Error, iter, v any) bool {
	if msg, ok := checkNotContains(iter, v); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that iter does not contain value v. Iter must be one of: map, slice, array, or string
func NotContainsf(t Error, iter, v any, format string, args ...any) bool {
	if msg, ok := checkNotContains(iter, v); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that iter does not contain value v. Iter must be one of: map, slice, array, or string
func MustNotContain(t Fatal, iter, v any) {
	if msg, ok := checkNotContains(iter, v); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that iter does not contain value v. Iter must be one of: map, slice, array, or string
func MustNotContainf(t Fatal, iter, v any, format string, args ...any) {
	if msg, ok := checkNotContains(iter, v); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that the given function panics.
func Panics(t Error, fn func()) bool {
	if msg, ok := checkPanics(fn); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that the given function panics.
func Panicsf(t Error, fn func(), format string, args ...any) bool {
	if msg, ok := checkPanics(fn); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that the given function panics.
func MustPanic(t Fatal, fn func()) {
	if msg, ok := checkPanics(fn); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that the given function panics.
func MustPanicf(t Fatal, fn func(), format string, args ...any) {
	if msg, ok := checkPanics(fn); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that the given function does not panic.
func NotPanics(t Error, fn func()) bool {
	if msg, ok := checkNotPanics(fn); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that the given function does not panic.
func NotPanicsf(t Error, fn func(), format string, args ...any) bool {
	if msg, ok := checkNotPanics(fn); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that the given function does not panic.
func MustNotPanic(t Fatal, fn func()) {
	if msg, ok := checkNotPanics(fn); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that the given function does not panic.
func MustNotPanicf(t Fatal, fn func(), format string, args ...any) {
	if msg, ok := checkNotPanics(fn); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Check that the given function panics with the given value.
func PanicsWith(t Error, recovers any, fn func()) bool {
	if msg, ok := checkPanicsWith(recovers, fn); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Check that the given function panics with the given value.
func PanicsWithf(t Error, recovers any, fn func(), format string, args ...any) bool {
	if msg, ok := checkPanicsWith(recovers, fn); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Check that the given function panics with the given value.
func MustPanicWith(t Fatal, recovers any, fn func()) {
	if msg, ok := checkPanicsWith(recovers, fn); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Check that the given function panics with the given value.
func MustPanicWithf(t Fatal, recovers any, fn func(), format string, args ...any) {
	if msg, ok := checkPanicsWith(recovers, fn); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Poll the given function, a max of numTries times, until it returns true.
func EventuallyTrue(t Error, numTries int, fn func(i int) bool) bool {
	if msg, ok := checkEventuallyTrue(numTries, fn); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Poll the given function, a max of numTries times, until it returns true.
func EventuallyTruef(t Error, numTries int, fn func(i int) bool, format string, args ...any) bool {
	if msg, ok := checkEventuallyTrue(numTries, fn); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Poll the given function, a max of numTries times, until it returns true.
func MustEventuallyTrue(t Fatal, numTries int, fn func(i int) bool) {
	if msg, ok := checkEventuallyTrue(numTries, fn); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Poll the given function, a max of numTries times, until it returns true.
func MustEventuallyTruef(t Fatal, numTries int, fn func(i int) bool, format string, args ...any) {
	if msg, ok := checkEventuallyTrue(numTries, fn); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}

// Poll the given function, a max of numTries times, until it doesn't return an error. This is mainly a helper used to exhaust error pathways.
func EventuallyNil(t Error, numTries int, fn func(i int) error) bool {
	if msg, ok := checkEventuallyNil(numTries, fn); !ok {
		t.Helper()
		t.Error("\n" + msg)
		return false
	}

	return true
}

// Poll the given function, a max of numTries times, until it doesn't return an error. This is mainly a helper used to exhaust error pathways.
func EventuallyNilf(t Error, numTries int, fn func(i int) error, format string, args ...any) bool {
	if msg, ok := checkEventuallyNil(numTries, fn); !ok {
		t.Helper()
		t.Error(fmt.Sprintf(format, args...) + "\n" + msg)
		return false
	}

	return true
}

// Poll the given function, a max of numTries times, until it doesn't return an error. This is mainly a helper used to exhaust error pathways.
func MustEventuallyNil(t Fatal, numTries int, fn func(i int) error) {
	if msg, ok := checkEventuallyNil(numTries, fn); !ok {
		t.Helper()
		t.Fatal("\n" + msg)
	}
}

// Poll the given function, a max of numTries times, until it doesn't return an error. This is mainly a helper used to exhaust error pathways.
func MustEventuallyNilf(t Fatal, numTries int, fn func(i int) error, format string, args ...any) {
	if msg, ok := checkEventuallyNil(numTries, fn); !ok {
		t.Helper()
		t.Fatal(fmt.Sprintf(format, args...) + "\n" + msg)
	}
}
